use bevy_ecs::{entity::Entity, event::Event};

use crate::map::direction::Direction;

/// Player input commands that trigger specific game actions.
///
/// Commands are generated by the input system in response to keyboard events
/// and processed by appropriate game systems to modify state or behavior.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum GameCommand {
    /// Request immediate game shutdown
    Exit,
    /// Set Pac-Man's movement direction
    MovePlayer(Direction),
    /// Cycle through debug visualization modes
    ToggleDebug,
    /// Toggle audio mute state
    MuteAudio,
    /// Restart the current level with fresh entity positions and items
    ResetLevel,
    /// Pause or resume game ticking logic
    TogglePause,
}

/// Global events that flow through the ECS event system to coordinate game behavior.
///
/// Events enable loose coupling between systems - input generates commands, collision
/// detection reports overlaps, and various systems respond appropriately without
/// direct dependencies.
#[derive(Event, Clone, Copy, Debug, PartialEq, Eq)]
pub enum GameEvent {
    /// Player input command to be processed by relevant game systems
    Command(GameCommand),
    /// Physical overlap detected between two entities requiring gameplay response
    Collision(Entity, Entity),
}

impl From<GameCommand> for GameEvent {
    fn from(command: GameCommand) -> Self {
        GameEvent::Command(command)
    }
}

/// Data for requesting stage transitions; processed centrally in stage_system
#[derive(Event, Clone, Copy, Debug, PartialEq, Eq)]
pub enum StageTransition {
    GhostEatenPause { ghost_entity: Entity },
}
